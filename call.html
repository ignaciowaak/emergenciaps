<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Ayuda en Tiempo Real</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* Esta regla sigue siendo necesaria para el control dinámico con JavaScript */
    .hidden {
      display: none !important; /* Usamos !important para asegurar que esta regla gane */
    }
    :root {
      --ios-primary: #007AFF;
      --ios-background: rgba(242,242,247,0.9);
      --ios-blur: blur(20px);
      --ios-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f9; margin:0; min-height:100vh;
      display:flex; justify-content:center; align-items:center;
      flex-wrap: wrap;
      gap: 20px;
    }
    .card {
      background: var(--ios-background); backdrop-filter: var(--ios-blur);
      box-shadow: var(--ios-shadow); border-radius:14px;
      padding:2rem; width:90%; max-width:400px; text-align:center;
      flex-shrink: 0;
      /* Transición simple para que la aparición/desaparición sea menos abrupta */
      transition: opacity 0.3s ease, transform 0.3s ease;
      opacity: 1;
      transform: scale(1);
    }
    /* Estilo para las tarjetas ocultas (complementa display: none) */
    .card.hidden {
       opacity: 0;
       transform: scale(0.95);
       /* Nota: display: none se encarga de que no ocupen espacio,
          la transición se aplica al añadir/quitar la clase ANTES de que
          display: none actúe completamente. */
    }

    h2 { margin-top:0; color:#1c1c1e; }
    select, input, button {
      width:100%; margin:.5rem 0; padding:.75rem;
      border-radius:10px; border:1px solid rgba(0,0,0,0.1);
      font-size:1rem; box-sizing: border-box;
    }
    button {
      background: var(--ios-primary); color:#fff; border:none;
      font-weight:500; cursor:pointer;
    }
    button:active { transform:scale(0.98); }
    #status { margin-top:1rem; font-weight:500; color:#3a3a3c; }
    #remoteAudio { margin-top:1rem; width:100%; display: none; }
    #chatSection, #callSection { display:flex; flex-direction:column; gap:1rem; }
     #requestSection { display:flex; flex-direction:column; gap:1rem; align-items: center; }
    #requestSection h2,
    #requestSection select,
    #requestSection input,
    #requestSection button,
    #requestSection #status {
        width: 100%;
        margin: 0.5rem 0;
    }

    #messages { flex:1; overflow-y:auto; border:1px solid rgba(0,0,0,0.1); border-radius:10px; padding:1rem; background:#fff; max-height:200px; text-align:left; display: flex; flex-direction: column; }
    .message { margin:0.25rem 0; word-wrap: break-word; }
    .message span { display: block; }
    .sent { text-align:right; color:#000; }
    .sent span:first-child { color: var(--ios-primary); font-weight: 500; font-size: 0.9em; }
     .sent span:last-child { margin-top: 0.1em; }

    .received { text-align:left; color:#000; }
    .received span:first-child { color: #5856d6; font-weight: 500; font-size: 0.9em; }
     .received span:last-child { margin-top: 0.1em; }

  </style>
</head>
<body>
  <div class="card" id="requestSection">
    <h2>¿Necesitas Ayuda?</h2>
    <select id="requestType">
      <option value="chat">Chat de Emergencia</option>
      <option value="call">Llamada de Emergencia</option>
    </select>
    <input type="text" id="userName" placeholder="Tu nombre (opcional)">
    <button id="btnRequest">Enviar Solicitud</button>
    <p id="status">Estado: Listo para enviar</p>
  </div>

  <div class="card hidden" id="waitingSection" style="display: none;">
    <h2>Solicitud Enviada</h2>
    <p id="waitingMsg">Espera a que un asistente acepte tu solicitud...</p>
    <button id="cancelBtn">Cancelar Solicitud</button>
  </div>

  <div class="card hidden" id="chatSection" style="display: none;">
    <h2>Chat de Emergencia</h2>
    <div id="messages"></div>
    <input type="text" id="chatInput" placeholder="Escribe tu mensaje">
    <button id="sendChatBtn">Enviar</button>
  </div>

  <div class="card hidden" id="callSection" style="display: none;">
    <h2>Llamada de Emergencia</h2>
    <p id="callStatus">Conectando...</p>
    <button id="hangUpBtn" disabled>Colgar</button>
    <audio id="remoteAudio" controls autoplay></audio>
  </div>

  <script type="module">
    import { initializeApp }      from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js';
    import { getDatabase, ref, push, serverTimestamp, onValue, set, remove, off } from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js';

    const cfg = {
      apiKey: "AIzaSyA_USvfSXAqZf7hQhJCon0WulrINB7cI", // Reemplaza con tu API Key real
      authDomain: "the-pic-c437e.firebaseapp.com",
      databaseURL: "https://the-pic-c437e-default-rtdb.firebaseio.com",
      projectId: "the-pic-c437e",
      storageBucket: "the-pic-c437e.appspot.com",
      messagingSenderId: "750954597180",
      appId: "1:750954597180:web:d7b67c6b60f4d3bb17ec39"
    };
    const app = initializeApp(cfg);
    const db  = getDatabase(app);

    // Elementos
    const reqSec     = document.getElementById('requestSection');
    const waitSec    = document.getElementById('waitingSection');
    const chatSec    = document.getElementById('chatSection');
    const callSec    = document.getElementById('callSection');
    const statusEl   = document.getElementById('status');
    const waitingMsg = document.getElementById('waitingMsg');

    const btnReq     = document.getElementById('btnRequest');
    const btnCancel  = document.getElementById('cancelBtn');
    const typeSel    = document.getElementById('requestType');
    const nameInput  = document.getElementById('userName');

    let roomKey, reqType;
    let statusListener = null;
    let pc, localStream;

    // Esta función asegura el estado de visibilidad usando las clases 'hidden'.
    // La llamamos al inicio del script para confirmar el estado visual
    // y también la usamos para volver al estado inicial si es necesario.
    function setDisplayState(sectionToShowId) {
        console.log(`Estableciendo estado de visualización: mostrar ${sectionToShowId}`);
        reqSec.classList.add('hidden');
        waitSec.classList.add('hidden');
        chatSec.classList.add('hidden');
        callSec.classList.add('hidden');

        // Eliminar el estilo inline display: none antes de remover la clase hidden
        // Esto permite que la transición CSS (si existe) funcione
         [reqSec, waitSec, chatSec, callSec].forEach(sec => {
             sec.style.display = ''; // Eliminar el estilo inline
         });


        const sectionToShow = document.getElementById(sectionToShowId);
        if (sectionToShow) {
             sectionToShow.classList.remove('hidden'); // Muestra la sección deseada
             console.log(`${sectionToShowId} ahora es visible.`);
        } else {
            console.error(`Error: Sección con ID ${sectionToShowId} no encontrada.`);
        }
    }

    // Establecer el estado inicial al cargar: solo mostrar requestSection
    // La sección ya empieza oculta por el style="display: none;" en el HTML,
    // pero esta llamada asegura que si el JS carga muy rápido, se aplican las clases.
     setDisplayState('requestSection');


    btnReq.onclick = () => {
      reqType = typeSel.value;
      const name = nameInput.value.trim() || 'Anónimo';

      const newReqRef = push(ref(db, 'requests'));
      roomKey = newReqRef.key;

      set(newReqRef, { type: reqType, name, status: 'pending', timestamp: serverTimestamp() })
      .then(() => {
        console.log(`Solicitud ${roomKey} (${reqType}) enviada a Firebase.`);
        // Ocultar la sección de solicitud y mostrar la de espera
        setDisplayState('waitingSection');
        waitingMsg.textContent = `Esperando a que un asistente acepte tu solicitud (${reqType === 'chat' ? 'Chat' : 'Llamada'})...`;
        statusEl.textContent = '';

        if(statusListener) off(ref(db, `requests/${roomKey}/status`), statusListener);

        statusListener = onValue(ref(db, `requests/${roomKey}/status`), snap => {
          const st = snap.val();
          console.log(`Estado de la solicitud ${roomKey}: ${st}`);
          if (st === 'accepted') {
            console.log('Solicitud aceptada. Inicializando:', reqType);
            if(statusListener) off(ref(db, `requests/${roomKey}/status`), statusListener);
            statusListener = null;

            // Muestra la sección correcta
            if (reqType === 'chat') initChat();
            else initCall();

          } else if (st === 'cancelled') {
            console.log('Solicitud cancelada.');
            if(statusListener) off(ref(db, `requests/${roomKey}/status`), statusListener);
            statusListener = null;
            alert('Tu solicitud fue cancelada.');
            location.reload(); // Recargar para volver al estado inicial

          } else if (st === null && roomKey) {
              console.log('Solicitud eliminada por admin.');
              if(statusListener) off(ref(db, `requests/${roomKey}/status`), statusListener);
              statusListener = null;
              alert('Tu solicitud ha sido cerrada o eliminada.');
              location.reload();
          }
        });
      })
      .catch(error => {
          console.error("Error al enviar la solicitud:", error);
          statusEl.textContent = `Error al enviar solicitud: ${error.message}`;
          // Volver a mostrar la sección de solicitud si falla el envío
          setDisplayState('requestSection'); // Vuelve al estado inicial
      });
    };

    btnCancel.onclick = () => {
       if (roomKey) {
           set(ref(db, `requests/${roomKey}/status`), 'cancelled')
           .catch(error => {
                console.error("Error al actualizar el estado a cancelled:", error);
           })
           .finally(() => {
               remove(ref(db, `requests/${roomKey}`))
               .then(() => {
                   console.log('Solicitud cancelada y eliminada.');
                   if(statusListener) off(ref(db, `requests/${roomKey}/status`), statusListener);
                   statusListener = null;
                   location.reload();
               })
               .catch(error => {
                   console.error("Error al eliminar la solicitud:", error);
                   alert('Error al cancelar la solicitud. Por favor, recarga la página.');
                   if(statusListener) off(ref(db, `requests/${roomKey}/status`), statusListener);
                   statusListener = null;
                   location.reload();
               });
           });
       } else {
           console.log('No hay solicitud activa para cancelar.');
           location.reload();
       }
    };

    // — Chat —
    function initChat() {
      // Asegurarse de que solo la sección de chat es visible
      setDisplayState('chatSection'); // Muestra la sección de chat

      const msgsEl = document.getElementById('messages');
      const chatInput = document.getElementById('chatInput');
      const sendChatBtn = document.getElementById('sendChatBtn');

      const handleSendClick = () => {
         const text = chatInput.value.trim();
         if (!text || !roomKey) return;

         const userName = nameInput.value.trim() || 'Usuario';
         push(ref(db, `chats/${roomKey}`), { user: userName, text, timestamp: serverTimestamp() })
         .then(() => {
              chatInput.value = '';
         })
         .catch(error => {
             console.error("Error al enviar mensaje:", error);
         });
      };
      sendChatBtn.onclick = handleSendClick;

       chatInput.addEventListener('keypress', function(event) {
           if (event.key === 'Enter') {
               event.preventDefault();
               sendChatBtn.click();
           }
       });

      onValue(ref(db, `chats/${roomKey}`), snap => {
        msgsEl.innerHTML = '';
        if (snap.exists()) {
            const messages = snap.val();
            const sortedMessages = Object.values(messages).sort((a, b) => a.timestamp - b.timestamp);

            sortedMessages.forEach(m => {
              const d = document.createElement('div');
              const userName = nameInput.value.trim() || 'Usuario';
              const isSent = m.user === userName;
              d.className = 'message ' + (isSent ? 'sent' : 'received');
              d.innerHTML = `<span>${m.user}</span><span>${m.text}</span>`;
              msgsEl.append(d);
            });
        }
        msgsEl.scrollTop = msgsEl.scrollHeight;
      });
    }

    // — Llamada —
    async function initCall() {
      // Asegurarse de que solo la sección de llamada es visible
      setDisplayState('callSection'); // Muestra la sección de llamada


      const callStatusEl = document.getElementById('callStatus');
      const hangUpBtn = document.getElementById('hangUpBtn');
      const remoteAudio = document.getElementById('remoteAudio');

      callStatusEl.textContent = 'Solicitando acceso al micrófono...';
      try {
          localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          console.log('Acceso al micrófono concedido.');
          callStatusEl.textContent = 'Conectando llamada...';
      } catch (error) {
          console.error('Error al obtener acceso al micrófono:', error);
          callStatusEl.textContent = 'Error: Permite acceso al micrófono.';
          alert('Necesitas permitir el acceso al micrófono para la llamada.');
          endCall();
          return;
      }

      pc = new RTCPeerConnection({
          iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
          ]
      });
      console.log('RTCPeerConnection creada.');

      localStream.getTracks().forEach(track => {
          console.log('Añadiendo pista de audio local.');
          pc.addTrack(track, localStream);
      });

      pc.ontrack = event => {
        console.log('Pista remota recibida:', event.track.kind);
        if (event.track.kind === 'audio') {
           remoteAudio.srcObject = event.streams[0];
           remoteAudio.style.display = 'block';
           console.log('Audio remoto adjuntado.');
        }
      };

      pc.onicecandidate = event => {
          if (event.candidate) {
              console.log('Candidato ICE local generado:', event.candidate);
              push(ref(db, `calls/${roomKey}/calleeCandidates`), JSON.stringify(event.candidate))
              .catch(error => console.error('Error al enviar candidato ICE local:', error));
          } else {
              console.log('Fin de candidatos ICE locales.');
          }
      };

      pc.oniceconnectionstatechange = () => {
          console.log(`Estado ICE: ${pc.iceConnectionState}`);
           callStatusEl.textContent = `Estado ICE: ${pc.iceConnectionState}`;
      };

      pc.onconnectionstatechange = () => {
          console.log(`Estado de Conexión: ${pc.connectionState}`);
           callStatusEl.textContent = `Estado: ${pc.connectionState}`;
           if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
               console.log('Conexión terminada o fallida.');
               endCall();
           } else if (pc.connectionState === 'connected') {
               console.log('Conexión establecida!');
                callStatusEl.textContent = 'Llamada Conectada';
                hangUpBtn.disabled = false;
           }
      };

      pc.onerror = (error) => {
          console.error('Error en RTCPeerConnection:', error);
          callStatusEl.textContent = `Error: ${error.message}`;
          alert('Se produjo un error en la llamada.');
          endCall();
      };

      onValue(ref(db, `calls/${roomKey}/offer`), async snap => {
          if (!snap.exists()) {
              console.log('No hay oferta en la base de datos.');
              return;
          }
          const offer = JSON.parse(snap.val());
          console.log('Oferta recibida:', offer);

          try {
               if (pc.signalingState !== 'stable') {
                    console.warn('Estado de señalización no es estable, intentando establecer descripción remota...');
               }
              await pc.setRemoteDescription(new RTCSessionDescription(offer));
              console.log('Descripción remota (oferta) establecida.');

              const answer = await pc.createAnswer();
              console.log('Respuesta creada:', answer);
              await pc.setLocalDescription(answer);
              console.log('Descripción local (respuesta) establecida.');

              await set(ref(db, `calls/${roomKey}/answer`), JSON.stringify(answer));
              console.log('Respuesta enviada a Firebase.');

               callStatusEl.textContent = 'Estableciendo conexión...';

          } catch (error) {
              console.error('Error al procesar la oferta o crear respuesta:', error);
              callStatusEl.textContent = `Error en la llamada: ${error.message}`;
               alert('Error al iniciar la llamada.');
               endCall();
          }
      });

       onValue(ref(db, `calls/${roomKey}/callerCandidates`), async snap => {
            if (!snap.exists()) {
                 console.log('No hay candidatos del caller (admin) aún.');
                 return;
            }
            const candidates = snap.val();
            console.log('Candidatos del caller recibidos:', candidates);

            for (const key in candidates) {
                try {
                    const candidate = JSON.parse(candidates[key]);
                    pc.addIceCandidate(new RTCIceCandidate(candidate))
                     .then(() => console.log('Candidato ICE del caller añadido:', candidate))
                     .catch(error => console.error('Error al añadir candidato ICE del caller:', error));
                } catch (error) {
                    console.error('Error al parsear candidato ICE del caller:', error);
                }
            }
       });

      function endCall() {
          console.log('Finalizando llamada...');

          if (roomKey) {
              off(ref(db, `calls/${roomKey}/offer`));
              off(ref(db, `calls/${roomKey}/callerCandidates`));
          }

          if (pc && pc.connectionState !== 'closed') {
              console.log('Cerrando RTCPeerConnection.');
              pc.close();
              pc = null;
          }
          if (localStream) {
              console.log('Deteniendo pistas locales.');
              localStream.getTracks().forEach(track => track.stop());
              localStream = null;
          }
          if (remoteAudio) {
              console.log('Limpiando audio remoto.');
              remoteAudio.srcObject = null;
              remoteAudio.style.display = 'none';
          }

           if (roomKey) {
               remove(ref(db, `calls/${roomKey}/calleeCandidates`)).catch(e => console.warn("Error al limpiar candidatos locales:", e));
               remove(ref(db, `calls/${roomKey}/answer`)).catch(e => console.warn("Error al limpiar respuesta local:", e));
           }

          callStatusEl.textContent = 'Llamada finalizada';
          hangUpBtn.disabled = true;

          setTimeout(() => {
              if (!statusListener) {
                   console.log("Forzando recarga porque el listener de status no está activo.");
                   location.reload();
              } else {
                   console.log("El listener de status está activo y debería manejar la recarga.");
              }
          }, 2000);
      }

       hangUpBtn.onclick = endCall;

       window.addEventListener('beforeunload', async () => {
            console.log('Limpiando recursos antes de cerrar la ventana...');
            if (pc && pc.connectionState !== 'closed') {
                 console.log('Cerrando RTCPeerConnection en beforeunload.');
                 pc.close();
            }
             if (localStream) {
                console.log('Deteniendo pistas locales en beforeunload.');
                localStream.getTracks().forEach(track => track.stop());
            }
             if (roomKey) {
                 try {
                    await remove(ref(db, `calls/${roomKey}/calleeCandidates`));
                    await remove(ref(db, `calls/${roomKey}/answer`));
                    console.log('Datos de Firebase del usuario intentados limpiar al cerrar.');
                 } catch (e) {
                     console.warn('No se pudieron limpiar todos los datos de Firebase al cerrar:', e);
                 }
             }
       });

    }
  </script>
</body>
</html>
